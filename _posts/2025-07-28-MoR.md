---
title: "Mixture of Recursions"
date: 2025-07-21
---

# Background

# Result


## Mixture of Depths

Mixture of Depths (MoD) is an optimization technique for transformer models that allows different tokens to use varying amounts of computation by selectively routing tokens through layers. Instead of processing every token through every layer, MoD uses learned routing scores to determine which tokens receive full self-attention computation and which can skip layers with just residual connections. This adaptive approach exploits the natural variation in token complexity—simple tokens like "the" or "and" require less processing than semantically rich tokens—achieving 2-3x inference speedup with minimal quality degradation by dynamically allocating computational resources where they're most needed.

*Reference: Raposo, D., Ritter, S., Santoro, A., Wayne, G., Weber, T., Botvinick, M., van Hasselt, H., & Song, F. (2024). Mixture-of-Depths: Dynamically allocating compute in transformer-based language models. arXiv preprint arXiv:2404.02258.*

```mermaid
%%{init: {'theme':'base', 'themeVariables': {'primaryColor': '#4A90E2', 'primaryTextColor': '#ffffff', 'primaryBorderColor': '#2E5C8A', 'lineColor': '#333333', 'secondaryColor': '#E74C3C', 'tertiaryColor': '#95A5A6', 'background': '#ffffff', 'mainBkg': '#ffffff', 'secondBkg': '#ffffff', 'tertiaryBkg': '#ffffff'}}}%%
graph TD
    subgraph S1 ["Step 1: Initial Tokens"]
        T1[Token 1]
        T2[Token 2]
        T3[Token 3]
        T4[Token 4]
        T5[Token 5]
    end
    
    subgraph Filter1 ["Random Selection Process"]
        F1[Random Filter A]
    end
    
    subgraph S2 ["Step 2: First Random Selection"]
        T6[Token 1]
        T7[Token 2] 
        T8[Token 3]
        T9[Token 4]
        T10[Token 5]
    end
    
    subgraph Filter2 ["Random Selection Process"]
        F2[Random Filter B]
    end
    
    subgraph S3 ["Step 3: Second Random Selection"]
        T11[Token 1]
        T12[Token 2]
        T13[Token 3]
        T14[Token 4]
        T15[Token 5]
    end
    
    %% Consecutive connections
    T1 --> F1
    T2 --> F1
    T3 --> F1
    T4 --> F1
    T5 --> F1
    
    F1 --> T6
    F1 --> T7
    F1 --> T8
    F1 --> T9
    F1 --> T10
    
    T6 --> F2
    T7 --> F2
    T8 --> F2
    T9 --> F2
    T10 --> F2
    
    F2 --> T11
    F2 --> T12
    F2 --> T13
    F2 --> T14
    F2 --> T15
    
    %% Styling for subgraphs
    style S1 fill:#ffffff,stroke:#333,stroke-width:2px
    style S2 fill:#ffffff,stroke:#333,stroke-width:2px
    style S3 fill:#ffffff,stroke:#333,stroke-width:2px
    style Filter1 fill:#ffffff,stroke:#333,stroke-width:2px
    style Filter2 fill:#ffffff,stroke:#333,stroke-width:2px
    
    %% Step 1: All tokens active (blue)
    style T1 fill:#4A90E2,stroke:#2E5C8A,stroke-width:2px,color:#fff
    style T2 fill:#4A90E2,stroke:#2E5C8A,stroke-width:2px,color:#fff
    style T3 fill:#4A90E2,stroke:#2E5C8A,stroke-width:2px,color:#fff
    style T4 fill:#4A90E2,stroke:#2E5C8A,stroke-width:2px,color:#fff
    style T5 fill:#4A90E2,stroke:#2E5C8A,stroke-width:2px,color:#fff
    
    %% Step 2: Random elimination (Tokens 1 and 4 eliminated)
    style T6 fill:#E74C3C,stroke:#A93226,stroke-width:2px,color:#fff
    style T7 fill:#4A90E2,stroke:#2E5C8A,stroke-width:2px,color:#fff
    style T8 fill:#4A90E2,stroke:#2E5C8A,stroke-width:2px,color:#fff
    style T9 fill:#E74C3C,stroke:#A93226,stroke-width:2px,color:#fff
    style T10 fill:#4A90E2,stroke:#2E5C8A,stroke-width:2px,color:#fff
    
    %% Step 3: Tokens 1 and 4 back, but 2 and 3 eliminated
    style T11 fill:#4A90E2,stroke:#2E5C8A,stroke-width:2px,color:#fff
    style T12 fill:#E74C3C,stroke:#A93226,stroke-width:2px,color:#fff
    style T13 fill:#E74C3C,stroke:#A93226,stroke-width:2px,color:#fff
    style T14 fill:#4A90E2,stroke:#2E5C8A,stroke-width:2px,color:#fff
    style T15 fill:#4A90E2,stroke:#2E5C8A,stroke-width:2px,color:#fff
    
    %% Gray filter boxes
    style F1 fill:#95A5A6,stroke:#7F8C8D,stroke-width:2px,color:#fff
    style F2 fill:#95A5A6,stroke:#7F8C8D,stroke-width:2px,color:#fff
```

<div align="center" style="margin-top: 20px; padding: 15px;; border-radius: 8px>

**MoD Token Filtering Process** 🔵 (Active tokens) 🔴 (Elimintaed Tokens)

*The Mixture of Depths (MoD) algorithm progressively reduces the token set through recursive filtering, retaining only the most semantically relevant tokens for downstream processing.*

</div>


## Mixture of Recursions

Mixture of Recursions (MoR) extends the efficiency principles of Mixture of Depths by introducing hierarchical token filtering through recursive processing stages. While MoD focuses on layer-wise token routing within a single forward pass, MoR applies token-level selection across multiple recursive iterations, progressively refining the active token set at each stage. Inspired by both MoD's adaptive computation allocation and token-level pruning techniques, MoR creates a multi-stage filtering pipeline where tokens compete for computational resources across recursive depths rather than transformer layers. This hierarchical approach allows for more aggressive token reduction while maintaining semantic coherence, as each recursive stage can focus on increasingly refined subsets of the most relevant tokens, potentially achieving even greater efficiency gains than traditional depth-based routing methods.

*Note: This appears to be a novel approach building on established MoD principles - specific citation pending publication.*

```mermaid
%%{init: {'theme':'base', 'themeVariables': {'primaryColor': '#4A90E2', 'primaryTextColor': '#ffffff', 'primaryBorderColor': '#2E5C8A', 'lineColor': '#333333', 'secondaryColor': '#E74C3C', 'tertiaryColor': '#95A5A6', 'background': '#ffffff', 'mainBkg': '#ffffff', 'secondBkg': '#ffffff', 'tertiaryBkg': '#ffffff'}}}%%
graph TD
    subgraph S1 ["Step 1: Initial Tokens"]
        T1[Token 1]
        T2[Token 2]
        T3[Token 3]
        T4[Token 4]
        T5[Token 5]
    end
    
    subgraph Filter1 ["Filtering Process"]
        F1[Token Selection]
    end
    
    subgraph S2 ["Step 2: Recursion Level 1"]
        T6[Token 1]
        T7[Token 2] 
        T8[Token 3]
        T9[Token 4]
        T10[Token 5]
    end
    
    subgraph Filter2 ["Filtering Process"]
        F2[Token Selection]
    end
    
    subgraph S3 ["Step 3: Final Output"]
        T11[Token 1]
        T12[Token 2]
        T13[Token 3]
        T14[Token 4]
        T15[Token 5]
    end
    
    %% Connections
    T1 --> F1
    T2 --> F1
    T3 --> F1
    T4 --> F1
    T5 --> F1
    
    F1 --> T6
    F1 --> T7
    F1 --> T8
    F1 --> T9
    F1 --> T10
    
    T6 --> F2
    T7 --> F2
    T8 --> F2
    T9 --> F2
    T10 --> F2
    
    F2 --> T11
    F2 --> T12
    F2 --> T13
    F2 --> T14
    F2 --> T15
    
    %% Styling for subgraphs
    style S1 fill:#ffffff,stroke:#333,stroke-width:2px
    style S2 fill:#ffffff,stroke:#333,stroke-width:2px
    style S3 fill:#ffffff,stroke:#333,stroke-width:2px
    style Filter1 fill:#ffffff,stroke:#333,stroke-width:2px
    style Filter2 fill:#ffffff,stroke:#333,stroke-width:2px
    
    %% Blue tokens (present/active)
    style T1 fill:#4A90E2,stroke:#2E5C8A,stroke-width:2px,color:#fff
    style T2 fill:#4A90E2,stroke:#2E5C8A,stroke-width:2px,color:#fff
    style T3 fill:#4A90E2,stroke:#2E5C8A,stroke-width:2px,color:#fff
    style T4 fill:#4A90E2,stroke:#2E5C8A,stroke-width:2px,color:#fff
    style T5 fill:#4A90E2,stroke:#2E5C8A,stroke-width:2px,color:#fff
    style T6 fill:#4A90E2,stroke:#2E5C8A,stroke-width:2px,color:#fff
    style T7 fill:#4A90E2,stroke:#2E5C8A,stroke-width:2px,color:#fff
    style T8 fill:#4A90E2,stroke:#2E5C8A,stroke-width:2px,color:#fff
    style T11 fill:#4A90E2,stroke:#2E5C8A,stroke-width:2px,color:#fff
    
    %% Red tokens (filtered out)
    style T9 fill:#E74C3C,stroke:#A93226,stroke-width:2px,color:#fff
    style T10 fill:#E74C3C,stroke:#A93226,stroke-width:2px,color:#fff
    style T12 fill:#E74C3C,stroke:#A93226,stroke-width:2px,color:#fff
    style T13 fill:#E74C3C,stroke:#A93226,stroke-width:2px,color:#fff
    style T14 fill:#E74C3C,stroke:#A93226,stroke-width:2px,color:#fff
    style T15 fill:#E74C3C,stroke:#A93226,stroke-width:2px,color:#fff
    
    %% Gray filter boxes
    style F1 fill:#95A5A6,stroke:#7F8C8D,stroke-width:2px,color:#fff
    style F2 fill:#95A5A6,stroke:#7F8C8D,stroke-width:2px,color:#fff
```


<div align="center" style="margin-top: 20px; padding: 15px;; border-radius: 8px>

**MoR Token Filtering Process** 🔵 (Active tokens) 🔴 (Elimintaed Tokens)

*The Mixture of Ranks (MoR) algorithm progressively reduces the token set through recursive filtering, retaining only the most semantically relevant tokens for downstream processing.*

</div>

## Caching Mechanisms: MoD vs MoR

The caching mechanism is a critical optimization in both MoD and MoR approaches, but they differ significantly in their implementation and efficiency. In MoD, caching occurs at the layer level where skipped tokens maintain their previous layer representations, requiring cache invalidation and updates as tokens move through different routing decisions across layers. MoR introduces a more sophisticated hierarchical caching system that leverages the recursive nature of its filtering process, allowing for persistent token state across recursive iterations and enabling more efficient cache reuse patterns.

```mermaid
%%{init: {'theme':'base', 'themeVariables': {'primaryColor': '#4A90E2', 'primaryTextColor': '#ffffff', 'primaryBorderColor': '#2E5C8A', 'lineColor': '#333333', 'secondaryColor': '#E74C3C', 'tertiaryColor': '#95A5A6', 'background': '#ffffff', 'mainBkg': '#ffffff', 'secondBkg': '#ffffff', 'tertiaryBkg': '#ffffff'}}}%%
graph TD
    subgraph Initial ["Initial Cache Grid (5x5 = 25 tokens)"]
        A1[T1] --- A2[T2] --- A3[T3] --- A4[T4] --- A5[T5]
        A6[T6] --- A7[T7] --- A8[T8] --- A9[T9] --- A10[T10]
        A11[T11] --- A12[T12] --- A13[T13] --- A14[T14] --- A15[T15]
        A16[T16] --- A17[T17] --- A18[T18] --- A19[T19] --- A20[T20]
        A21[T21] --- A22[T22] --- A23[T23] --- A24[T24] --- A25[T25]
        
        A1 --- A6
        A2 --- A7
        A3 --- A8
        A4 --- A9
        A5 --- A10
        A6 --- A11
        A7 --- A12
        A8 --- A13
        A9 --- A14
        A10 --- A15
        A11 --- A16
        A12 --- A17
        A13 --- A18
        A14 --- A19
        A15 --- A20
        A16 --- A21
        A17 --- A22
        A18 --- A23
        A19 --- A24
        A20 --- A25
    end
    
    subgraph Filter1 ["First Recursion Filter"]
        F1[Hierarchical Filter]
    end
    
    subgraph Reduced1 ["Reduced Cache Grid (3x3 = 9 tokens)"]
        B1[T1] --- B2[T3] --- B3[T5]
        B4[T11] --- B5[T13] --- B6[T15]
        B7[T21] --- B8[T23] --- B9[T25]
        
        B1 --- B4
        B2 --- B5
        B3 --- B6
        B4 --- B7
        B5 --- B8
        B6 --- B9
    end
    
    subgraph Filter2 ["Second Recursion Filter"]
        F2[Hierarchical Filter]
    end
    
    subgraph Final ["Final Cache Grid (2x2 = 4 tokens)"]
        C1[T1] --- C2[T5]
        C3[T21] --- C4[T25]
        
        C1 --- C3
        C2 --- C4
    end
    
    subgraph Mapping ["Cache Mapping Process"]
        M1[25→9 Mapping]
        M2[9→4 Mapping]
    end
    
    Initial --> F1
    F1 --> Reduced1
    Reduced1 --> F2
    F2 --> Final
    
    F1 --> M1
    F2 --> M2
    
    %% Styling - Initial grid (all blue)
    style A1 fill:#4A90E2,stroke:#2E5C8A,stroke-width:2px,color:#fff
    style A2 fill:#4A90E2,stroke:#2E5C8A,stroke-width:2px,color:#fff
    style A3 fill:#4A90E2,stroke:#2E5C8A,stroke-width:2px,color:#fff
    style A4 fill:#4A90E2,stroke:#2E5C8A,stroke-width:2px,color:#fff
    style A5 fill:#4A90E2,stroke:#2E5C8A,stroke-width:2px,color:#fff
    style A6 fill:#4A90E2,stroke:#2E5C8A,stroke-width:2px,color:#fff
    style A7 fill:#4A90E2,stroke:#2E5C8A,stroke-width:2px,color:#fff
    style A8 fill:#4A90E2,stroke:#2E5C8A,stroke-width:2px,color:#fff
    style A9 fill:#4A90E2,stroke:#2E5C8A,stroke-width:2px,color:#fff
    style A10 fill:#4A90E2,stroke:#2E5C8A,stroke-width:2px,color:#fff
    style A11 fill:#4A90E2,stroke:#2E5C8A,stroke-width:2px,color:#fff
    style A12 fill:#4A90E2,stroke:#2E5C8A,stroke-width:2px,color:#fff
    style A13 fill:#4A90E2,stroke:#2E5C8A,stroke-width:2px,color:#fff
    style A14 fill:#4A90E2,stroke:#2E5C8A,stroke-width:2px,color:#fff
    style A15 fill:#4A90E2,stroke:#2E5C8A,stroke-width:2px,color:#fff
    style A16 fill:#4A90E2,stroke:#2E5C8A,stroke-width:2px,color:#fff
    style A17 fill:#4A90E2,stroke:#2E5C8A,stroke-width:2px,color:#fff
    style A18 fill:#4A90E2,stroke:#2E5C8A,stroke-width:2px,color:#fff
    style A19 fill:#4A90E2,stroke:#2E5C8A,stroke-width:2px,color:#fff
    style A20 fill:#4A90E2,stroke:#2E5C8A,stroke-width:2px,color:#fff
    style A21 fill:#4A90E2,stroke:#2E5C8A,stroke-width:2px,color:#fff
    style A22 fill:#4A90E2,stroke:#2E5C8A,stroke-width:2px,color:#fff
    style A23 fill:#4A90E2,stroke:#2E5C8A,stroke-width:2px,color:#fff
    style A24 fill:#4A90E2,stroke:#2E5C8A,stroke-width:2px,color:#fff
    style A25 fill:#4A90E2,stroke:#2E5C8A,stroke-width:2px,color:#fff
    
    %% Reduced grid (selected tokens in green)
    style B1 fill:#27AE60,stroke:#1E8449,stroke-width:2px,color:#fff
    style B2 fill:#27AE60,stroke:#1E8449,stroke-width:2px,color:#fff
    style B3 fill:#27AE60,stroke:#1E8449,stroke-width:2px,color:#fff
    style B4 fill:#27AE60,stroke:#1E8449,stroke-width:2px,color:#fff
    style B5 fill:#27AE60,stroke:#1E8449,stroke-width:2px,color:#fff
    style B6 fill:#27AE60,stroke:#1E8449,stroke-width:2px,color:#fff
    style B7 fill:#27AE60,stroke:#1E8449,stroke-width:2px,color:#fff
    style B8 fill:#27AE60,stroke:#1E8449,stroke-width:2px,color:#fff
    style B9 fill:#27AE60,stroke:#1E8449,stroke-width:2px,color:#fff
    
    %% Final grid (most important tokens in gold)
    style C1 fill:#F39C12,stroke:#D68910,stroke-width:2px,color:#fff
    style C2 fill:#F39C12,stroke:#D68910,stroke-width:2px,color:#fff
    style C3 fill:#F39C12,stroke:#D68910,stroke-width:2px,color:#fff
    style C4 fill:#F39C12,stroke:#D68910,stroke-width:2px,color:#fff
    
    %% Filters and mapping
    style F1 fill:#95A5A6,stroke:#7F8C8D,stroke-width:2px,color:#fff
    style F2 fill:#95A5A6,stroke:#7F8C8D,stroke-width:2px,color:#fff
    style M1 fill:#8E44AD,stroke:#6C3483,stroke-width:2px,color:#fff
    style M2 fill:#8E44AD,stroke:#6C3483,stroke-width:2px,color:#fff
```

<div align="center" style="margin-top: 20px; padding: 15px; border-radius: 8px">

**MoR Hierarchical Cache Reduction** � (Initial (25 tokens) 🟢 (Filtered 9 tokens) 🟡 (Final 4 tokens) 🟣 (Mapping Process)

*MoR progressively reduces cache size from 5x5 grid (25 tokens) → 3x3 grid (9 tokens) → 2x2 grid (4 tokens), with efficient mapping between recursive stages maintaining spatial relationships and reducing memory footprint by 84%.*

</div>

### Computational Efficiency Analysis

**Traditional MoD Approach (3 × 5×5 grids):**
- Memory Operations: 3 × (5² = 25) = **75 cache entries**
- Attention Complexity: 3 × O(25²) = **3 × 625 = 1,875 operations**
- Cache Invalidations: High frequency due to layer-wise routing changes
- Total Memory Footprint: **75 × d_model bytes** (constant across layers)

**MoR Hierarchical Approach (5×5 → 3×3 → 2×2):**
- Memory Operations: 25 + 9 + 4 = **38 cache entries** (49% reduction)
- Attention Complexity: O(25²) + O(9²) + O(4²) = 625 + 81 + 16 = **722 operations** (62% reduction)
- Cache Invalidations: Minimal due to hierarchical persistence
- Total Memory Footprint: **Progressive reduction** from 25d to 4d model bytes

### Intermediary Mapping Matrices

MoR maintains efficient token relationships through sparse mapping matrices between recursion levels:

**First Mapping Matrix (25→9):**
```
M₁ ∈ ℝ^(9×25) where M₁[i,j] = {
  1 if token j maps to position i in reduced grid
  0 otherwise
}
```
- Sparsity: 9/25 = 36% non-zero entries
- Storage: 9 indices instead of 225 full matrix entries

**Second Mapping Matrix (9→4):**
```
M₂ ∈ ℝ^(4×9) where M₂[i,j] = {
  1 if token j maps to position i in final grid
  0 otherwise
}
```
- Sparsity: 4/9 = 44% non-zero entries
- Storage: 4 indices instead of 36 full matrix entries

### Efficiency Gains:

**Memory Efficiency:**
- Traditional: 75 cache entries across 3 layers
- MoR: 38 cache entries with progressive reduction
- **Savings: 49% memory reduction**

**Computational Efficiency:**
- Traditional: 1,875 attention operations
- MoR: 722 attention operations  
- **Savings: 62% computational reduction**

**Cache Management:**
- Traditional: O(n) invalidations per layer transition
- MoR: O(log n) mapping updates per recursion
- **Savings: Logarithmic vs linear cache management overhead**

The hierarchical structure enables **compound efficiency gains** where both memory and computation scale favorably, while sparse mapping matrices maintain token relationships with minimal overhead.